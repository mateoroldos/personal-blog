---
isDraft: false
title: "Yjs - An Engine for Modern Collaborative Apps"
description: "Discover how Yjs powers seamless collaboration in local-first applications"
date: "April 10, 2025"
tags: ["Local First", "Collaboration", "CRDTs"]
heroImage: "yjs.jpg"
---

import StepByStepAnimation from "../../components/StepByStepAnimation.svelte";

export const animationScenes = [
  {
    id: "step1",
    title: "User 0 inserts character 's'",
    imageSrc: "/animations/yjs/step_1.jpg",
  },
  {
    id: "step2",
    title: "Yjs assigns this character the id of (üë§ 0, üïê 0).",
    description:
      "The first 0 because it was inserted by User 0. The second because it's the first operation of this user (clock).",
    imageSrc: "/animations/yjs/step_2.jpg",
  },
  {
    id: "step3",
    title: "User 0 inserts the characters 'ale' at the right of the 's'",
    description:
      "Yjs assigns these characters the ids of (üë§ 0, üïê 1), (üë§ 0, üïê 2) and (üë§ 0, üïê 3).",
    imageSrc: "/animations/yjs/step_3.jpg",
  },
  {
    id: "step4",
    title: "Yjs will also keep relation of characters positions.",
    description: "It records previous and next character relationships",
    imageSrc: "/animations/yjs/step_4.jpg",
  },
  {
    id: "step5",
    title: "üõú User 1 and User 2 suddenly connect",
    description: "They both place a character between the 's' and the 'a'.",
    imageSrc: "/animations/yjs/step_5.jpg",
  },
  {
    id: "step6",
    title: "‚ö†Ô∏è We have a conflict",
    imageSrc: "/animations/yjs/step_6.jpg",
  },
  {
    id: "step7",
    title: "ü§ù Conflict Resolution",
    description:
      "When conflicts occur Yjs resolves it automatically. The character placed by the User with smaller User ID goes first. Easy, we have 'sctale'.",
    imageSrc: "/animations/yjs/step_7.jpg",
  },
  {
    id: "step7",
    title: "Descentralized Collaboration Unlocked",
    description:
      "Every client can now independently resolve conflicts and all will get to the same result. No central authority is needed to resolve conflicts.",
    imageSrc: "/animations/yjs/step_8.jpg",
  },
];

## Why Collaborative Editing Matters

Think about the last time you used Google Docs, Notion, or Figma with other people. Everyone types, everyone sees changes instantly, and nobody's work gets lost.

In this article, I'll deep dive into Yjs - **a powerful technology that enables scalable and efficient peer-to-peer collaboration.**

## The Evolution of Collaboration: From OT to CRDTs

To understand why Yjs matters, let's first look at how collaborative editing evolved over the last years.

### Operational Transformation (OT): The First _Wave_

Early collaborative systems like Google Docs used a technology called Operational Transformation (OT). The fundamental concept is simple:

1. Track every change as an operation ("insert H at position 0", "insert i at position 1")
2. Clients send each operation to a central server
3. The server decides the correct order of operations maintaining a single source of truth

This ideas work well and are easy to reason about - but this architecture has fundamental limitations:

- **Central server requirement**: OT needs a central server to establish operation order and resolve conflicts.

- **Performance bottlenecks**: The central server needs to process every edit. With many users, the server can get overwhelmed‚Äî_hence the "This document is overloaded" message you sometimes see in Google Docs._

These limitations led researchers to look for a better approach.

### CRDTs: The Breakthrough

CRDTs solve the collaboration problem with an elegant approach: embed conflict resolution inside the data structure itself.

The core insight is beautifully simple: **include the necessary metadata for conflict resolution inside the document itself and agree on a set of rules for handling conflicts.**

- **Each client can apply the same rules independently**
- **Every client reaches the same final state**
- **No central authority needed to resolve conflicts**

Early CRDTs were mostly theoretical because they had serious performance issues. The metadata needed for conflict resolution would often grow larger than the actual content.

Newer implementations like Yjs solve these performance problems with clever optimizations.

## Diving Deeper - How Yjs Works Under the Hood

So how does Yjs prevent conflicts when multiple people edit at the same time? Let's see how it works:

<StepByStepAnimation scenes={animationScenes} client:idle />

Easy, right? By knowing relative positions of each character and storing information of who and when inserted the character we can create a conflict-free history of our document.

To make this work effectively, Yjs relies on a fundamental data structure known as Items, which forms the backbone of its conflict resolution system.

### `Item` - The Core Building Block

`Item`s are the basic units of content in Yjs. In a text document, each character in a text is stored as an Item. Each Item has:

- **A unique identifier (client ID + logical clock)** - Tells us who created it and when
- **Content (text, object, etc.)** - The actual data users see
- **Position information (what comes before and after it)** - Keeps everything in the right order

```js
// Simplified representation of a Yjs Item

class Item {
  constructor(id, content, left, right) {
    this.id = id; // Unique identifier (clientID + clock)
    this.content = content; // The actual content (text, object, etc.)
    this.left = left; // Reference to the item before this one
    this.right = right; // Reference to the item after this one
  }
}
```

### Conflict Resolution Made Simple

When conflicts occur (like two users inserting at the same position), Yjs uses deterministic rules to resolve them:

1. If two Items want the same position, they're ordered by their creator's client ID
2. Lower client IDs come first (a simple but effective tie-breaker)

This may seem basic, but it's powerful: **every device applying these rules independently will reach exactly the same document state, without any communication or negotiation**.

When an update arrives, the document itself knows where to place the new Items, and in case of conflicts, it has all the necessary data to resolve it by itself. No central server needed to make these decisions - **the rules are built into the data**.

### The Efficiency Secret: Shared Sequences

Wait, wouldn't creating an `Item` for every character cause massive overhead? This takes us to one of Yjs's most important innovations.

Early CRDTs created a separate `Item` for each character in a document, causing massive overhead. Yjs takes a smarter approach:

**When you type `hello`, Yjs stores it as one `Item`, not five separate ones. `Item`s only split when changes happen in the middle of them. This simple optimization dramatically reduces memory usage and improves performance.**

As Kevin Jahns notes in his post [Are CRDTs Suitable for Shared Editing?](https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/)

> Most CRDTs assign a unique ID to every character that was ever created in the document. In Yjs, the complete document structure of a 100k character conference paper consists of only 11k Item objects instead of 260k objects for individual insertions/deletions. This type of compound representation dramatically reduces memory usage.

### Deletions Without Disruption

When content is deleted in Yjs, it isn't actually removed from the internal structure. Instead, it's marked as deleted in a `delete set`. This preserves the structural relationships between Items, ensuring consistent document reconstruction across all peers.

This approach keeps the relative positions of all content stable, avoiding the cascade of position changes that would happen if items were actually removed.

### Updates as Incremental Instructions

When changes are made to a Yjs document, Yjs generates compact update messages containing only the modified parts - not the entire document. These updates are binary-encoded instructions that precisely describe what changed, where it changed, and who made the change.

This approach means:

1. **Bandwidth efficiency** - Only sending what changed, not the entire document
2. **Conflict resilience** - Updates contain enough metadata to be applied in any order

When a client receives an update, it can apply these instructions to its local document state without requiring the sender's full context. This makes Yjs particularly efficient for large documents with frequent small changes - exactly the scenario in collaborative editing.

### State Vectors: Tracking Document Knowledge

Each client in a Yjs system maintains a state vector that defines the known state of each user. This vector is essentially a set of tuples in the form of (client, clock) that tracks exactly which operations from each client have been processed.

State vectors serve two critical purposes:

1. **Synchronization efficiency** - When clients connect, they exchange state vectors to determine which updates need to be sent
2. **Consistency verification** - Clients can verify they have the same document state by comparing vectors

## Building Applications with Yjs

Now that we understand the theory, let's see how to use Yjs in real applications.

### 1. The Y.Doc: Your Document Container

Every Yjs implementation starts with creating a Y.Doc‚Äîa shared container that holds all collaborative data:

```javascript
// Initialize the shared document
const ydoc = new Y.Doc();

// Each client gets a unique ID automatically
console.log(ydoc.clientID); // Unique client identifier

// Listen for updates to track changes
ydoc.on("update", update => {
  // The update is a binary-encoded change that can be sent to other peers
  console.log(update); // Uint8Array containing the update
});
```

The `Y.Doc` is like a box for your collaborative data. It generates a unique client ID, manages internal state, and emits updates when changes occur.

### 2. Shared Types for Different Data Needs

Inside a `Y.Doc`, you can access a map structure that organizes your collaborative data. This map associates string keys with content, similar to a JavaScript object. Within this map, you'll store "shared types" - specialized data structures designed for different kinds of collaborative data needs.

```javascript
// Text for collaborative editing (like a document)
const ytext = ydoc.getText("note-content");

// Map for key-value data (like metadata)
const ymeta = ydoc.getMap("note-metadata");

// Array for ordered lists (like todos)
const ytags = ydoc.getArray("note-tags");

// XML for tree structures (like rich text)
const yxml = ydoc.getXmlFragment("note-richtext");
```

### 3. Working with Shared Types

Using shared types feels similar to working with native JavaScript objects:

```javascript
// Working with shared text
ytext.insert(0, "Hello, world!"); // Insert text at position 0
ytext.delete(0, 5); // Delete 5 characters starting at position 0
ytext.toString(); // Convert to string

// Working with shared maps
ymeta.set("title", "My Note"); // Set a key-value pair
ymeta.get("title"); // Get a value
ymeta.has("title"); // Check if a key exists

// Working with shared arrays
ytags.push(["important"]); // Add to the end
ytags.delete(0, 1); // Delete one item at position 0
ytags.toArray(); // Convert to regular array
```

The magic happens because these operations automatically:

1. **Update the local document immediately**
2. **Generate update messages that can be sent to other peers**
3. **Apply conflict resolution rules when needed**

### 4. Transactions for Atomic Changes

When making multiple related changes, you can group them into transactions:

```javascript
// Group related changes in a transaction
ydoc.transact(() => {
  ytext.insert(0, "Title: ");
  ymeta.set("created", new Date().toISOString());
  ytags.push(["personal"]);
});
```

Transactions ensure that all changes are applied atomically‚Äîeither all succeed or none do. This helps maintain document consistency and generates a single update message containing all changes.

## Synchronization and Persistence

Yjs uses a modular architecture with different "providers" for various synchronization and storage needs.

### WebSocket for Real-time Collaboration

The y-websocket provider enables immediate synchronization when online:

```javascript
import { WebsocketProvider } from "y-websocket";

const wsProvider = new WebsocketProvider(
  "wss://notes-sync.example.com",
  "note-document-id",
  ydoc
);

// Handle connection status
wsProvider.on("status", event => {
  console.log("Connection status:", event.status);
});
```

This provider connects to a WebSocket server that handles real-time message distribution. It automatically syncs document changes between all connected clients.

### WebRTC for Peer-to-Peer Collaboration

The y-webrtc provider creates direct connections between browsers:

```javascript
import { WebrtcProvider } from "y-webrtc";

const webrtcProvider = new WebrtcProvider("note-document-id", ydoc, {
  signaling: ["wss://signaling.yjs.dev"],
});

// Monitor peer connections
webrtcProvider.on("peers", event => {
  console.log("Connected peers:", event.webrtcPeers.length);
});
```

WebRTC enables peer-to-peer connections, which can reduce latency and server load. It's particularly useful for applications that need to function even if the central server becomes unavailable.

### IndexedDB for Offline Persistence

The y-indexeddb provider stores document state in the browser's IndexedDB:

```javascript
import { IndexeddbPersistence } from "y-indexeddb";

const persistence = new IndexeddbPersistence("note-document-id", ydoc);

// Handle local storage syncing
persistence.on("synced", () => {
  console.log("Document loaded from local storage");
});
```

This provider ensures that documents persist between browser sessions. When the user reopens your app, their document loads from local storage‚Äîeven if they're offline.

### User Awareness

Beyond document content, Yjs includes a system for sharing user presence information:

```javascript
// Get the awareness instance from your provider
const awareness = wsProvider.awareness;

// Set your information
awareness.setLocalStateField("user", {
  name: "Alice",
  color: "#1a73e8",
  cursor: { position: 120, paragraph: 3 },
});

// Listen for changes from all users
awareness.on("change", changes => {
  // Get everyone's current information
  const states = awareness.getStates();

  // Update UI with this information
  updateUserList(states);
  updateCursors(states);
});
```

Awareness enables features like:

- Showing which users are currently in the document
- Displaying cursors and selections
- Indicating who's editing which section

Unlike document content, awareness information is ephemeral‚Äîit disappears when users disconnect.

## Advanced Features

### Collaborative Undo/Redo

Yjs includes built-in support for undo/redo that works across collaborators:

```javascript
import * as Y from "yjs";

// Create undo manager for shared text
const undoManager = new Y.UndoManager(ytext);

// Undo last local change
undoManager.undo();

// Redo previously undone change
undoManager.redo();

// Update UI based on stack status
undoManager.on("stack-item-added", () => {
  updateUndoRedoButtons();
});
```

The `UndoManager` tracks which changes came from which user, ensuring that people only undo their own changes‚Äîcrucial for collaborative editing.

### Document History and Snapshots

Yjs makes it easy to implement document history features:

```javascript
// Capture current document state
const snapshot = Y.snapshot(ydoc);

// Convert to storable format
const encodedSnapshot = Y.encodeSnapshot(snapshot);

// Later, load a saved snapshot
const decodedSnapshot = Y.decodeSnapshot(encodedSnapshot);

// Create a document from the snapshot
const previousDoc = Y.createDocFromSnapshot(ydoc, decodedSnapshot);
```

Snapshots are lightweight representations of document state that contain just enough information to reconstruct the document at a specific point in time. With snapshots, you can build features like version history, document comparisons, and point-in-time recovery.

## The Local-First Advantage

Yjs enables truly local-first applications with several key benefits:

1. **Offline-first operation**: Users can work without an internet connection
2. **Zero-latency editing**: Changes appear instantly without server roundtrips
3. **Seamless synchronization**: Changes merge automatically when connectivity returns
4. **Data ownership**: User data lives on their device first, not just in the cloud
5. **Resilience**: No single point of failure

These aren't just technical benefits‚Äîthey fundamentally improve the user experience:

- **Trust**: Users know their work won't disappear if their connection drops
- **Responsiveness**: The app feels fast because it doesn't wait for server responses
- **Autonomy**: Users control their data and can work anywhere

## Conclusion and Next Steps

CRDTs and Yjs represent a fundamental shift in how we build collaborative applications. By embedding conflict resolution in the data itself, we create experiences that are more resilient, responsive, and respectful of user autonomy.

In the next chapter, we'll put this knowledge into practice by building a collaborative note-taking application using Svelte, SvelteKit, and Yjs. You'll see firsthand how these concepts translate into working code.

### Further Reading

If you want to dive deeper before the next chapter:

- [Yjs Documentation](https://docs.yjs.dev/)
- [CRDT Explained](https://crdt.tech/) - A comprehensive resource about CRDTs
- [Are CRDTs Suitable for Shared Editing?](https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/) - Kevin Jahns' article on CRDT performance
- [Local-First Software](https://www.inkandswitch.com/local-first/) - The seminal paper on local-first development principles
- [Lars Hupel's Blog CRDT Series](https://lars.hupel.info/topics/crdt/01-intro/) - An approachable introduction to CRDTs by Lars Hupel
- [Bartosz Sypytkowski's Blog CRDT Series](https://www.bartoszsypytkowski.com/tag/crdt/) - Bartosz Sypytkowski's is a Yjs maintainer and shares awesome stuff in his blog
- [Tag1 Consulting Yjs Youtube Series](https://www.youtube.com/watch?v=_OwHt1lsyKk&list=PLASRuhw5l8pkZYv-IU7VjrQZgKOfRWD_0) - An awesome YouTube series exploring Yjs
